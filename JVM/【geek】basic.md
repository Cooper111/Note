# 只记录想提一下的，并不全



# 0x01 Java代码是如何运行的

总结与实践今天我简单介绍了 Java 代码为何在虚拟机中运行，以及如何在虚拟机中运行。

之所以要在虚拟机中运行，是因为它提供了可移植性。一旦 Java 代码被编译为 Java 字节码，便可以在不同平台上的 Java 虚拟机实现上运行。此外，虚拟机还提供了一个代码托管的环境，代替我们处理部分冗长而且容易出错的事务，例如内存管理、垃圾回收。

Java 虚拟机将运行时内存区域划分为五个部分，分别为**方法区、堆、PC 寄存器、Java 方法栈和本地方法栈**。Java 程序编译而成的 class 文件，需要先加载至**方法区**中，方能在 Java 虚拟机中运行。为了提高运行效率，标准 JDK 中的 HotSpot 虚拟机采用的是一种混合执行的策略。**它会解释执行 Java 字节码，然后会将其中反复执行的热点代码，以方法为单位进行即时编译，翻译成机器码后直接运行在底层硬件之上。**HotSpot 装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍。

课后作业

[通过字节码分析 Java 语言和 Java 虚拟机如何看待 boolean 类型](<https://blog.csdn.net/qq_40697071/article/details/103440581>)



# 0x02 Java的基本类型

在将 `boolean、byte、char 以及 short` 的值**存入字段或者数组单元时**，Java 虚拟机会进行**掩码操作**。**在读取时**，Java 虚拟机则会将**其扩展为 int 类型**。

我的理解：

- 栈上一样，就是解释器使用的解释栈帧上，程序进行==比对时，也就是读取时，`boolean、byte、char 以及 short`与int无异，当做int对比。
- 在堆上不一样，就是存储的时候，大小各异，所以会发生掩码

==================================分割线===============================================

- Java 虚拟机的 boolean 类型

  在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。

  ```java
  //上节课答案
  jvm把boolean当做int来处理
  flag = iconst_1 = true
  awk把stackframe中的flag改为iconst_2
  if（flag）比较时ifeq指令做是否为零判断，常数2仍为true，打印输出
  if（true == flag）比较时if_cmpne做整数比较，iconst_1是否等于flag，比较失败，不再打印输出
  //==============================================
  ifeq ：当操作数栈上数值为 0 时跳转；
  if_icmpne ：当操作数栈上两个数值不相同时跳转
  ```

- 在前面的例子中，我们能够将整数 2 存储到一个声明为 boolean 类型的局部变量中。那么，声明为 byte、char 以及 short 的局部变量，是否也能够**存储超出它们取值范围的数值**呢？**答案是可以的。**

  - Java 的浮点类型采用 IEEE 754 浮点数格式。以 float 为例，浮点类型通常有两个 0，+0.0F 以及 -0.0F。

  - 整数 0x7F800000 等同于正无穷，那么 0x7F800001 又对应什么浮点数呢？

    [0x7F800001, 0x7FFFFFFF]和[0xFF800001, 0xFFFFFFFF]对应的都是 NaN。当然，一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN。

  - NaN 有一个有趣的特性：除了“!=”始终返回 true 之外，所有其他比较结果都会返回 false。

    ```
    举例来说，“NaN<1.0F”返回 false，而“NaN>=1.0F”同样返回 false。对于任意浮点数 f，不管它是 0 还是 NaN，“f!=NaN”始终会返回 true，而“f==NaN”始终会返回 false。
    ```

- Java 基本类型的大小

  - java 虚拟机每调用一个 Java 方法，便会创建一个栈帧。为了方便理解，这里我只讨论供解释器使用的解释栈帧（这种栈帧有两个主要的组成部分，分别是**局部变量区**，以及**字节码的操作数栈**。这里的局部变量是广义的，除了普遍意义下的局部变量之外，它还`包含实例方法的“this 指针”以及方法所接收的参数`。

  - 在 Java 虚拟机规范中，**局部变量区等价于一个数组**，并且可以用正整数来索引。除了 long、double 值需要用**两个数组单元**来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。

  - boolean、byte、char、short 这四种类型，**在栈上占用的空间和 int 是一样的**，和引用类型也是一样的。在**存储于堆中的字段或者数组元素上，不一样**。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。

  - 因此，当我们将一个 int 类型的值，存储到这些类型的字段或数组时，相当于做了一次隐式的**掩码操作**。

    - 举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位的字节便会被截取掉，最终存入“\uFFFF”。
    - **boolean 字段和 boolean 数组则比较特殊**。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，**只取最后一位的值存入 boolean 字段或数组中**。所以，第一节课后习题答案，成立
    - 总结：除 long 和 double 外，其他基本类型与引用类型**在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同**。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。

  - 加载：Java 虚拟机的算数运算几乎全部依赖于操作数栈。也就是说，我们需要将堆中的 boolean、byte、char 以及 short 加载到操作数栈上，而后将栈上的值当成 int 类型来运算。

    ```
    对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。举个例子，char 的大小为两个字节。在加载时 char 的值会被复制到 int 类型的低二字节，而高二字节则会用 0 来填充。
    
    对于 byte、short 这两个类型来说，加载伴随着符号扩展。举个例子，short 的大小为两个字节。在加载时 short 的值同样会被复制到 int 类型的低二字节。如果该 short 值为非负数，即最高位为 0，那么该 int 类型的值的高二字节会用 0 来填充，否则用 1 来填充。
    ```

    

  

# 03 | Java虚拟机是如何加载Java类的?

- 【class-内存中类，步骤】从 class 文件到内存中的类，按先后顺序需要经过**加载**、**链接**以及**初始化**`三大步骤`。其中，链接过程中同样**需要验证**；而内存中的类没有经过初始化，同样不能使用。

- 【Java 语言的类型】**基本类型**（primitive types）和**引用类型**（reference types）。**Java 的基本类型由Java 虚拟机预先定义好的**，另一大类**引用类型**，Java 将其细分为四种：**类、接口、数组类**和**泛型参数**。泛型参数会在编译过程中被擦除；在类、接口和数组类中，**数组类**是由 **Java 虚拟机直接生成**的，其他两种则**有对应的字节流**。

- 字节流

  - 最常见的形式要属由 Java 编译器生成的 class 文件

  - 也可以在程序内部直接生成

  - 或者从网络中获取（例如网页中内嵌的小程序 Java applet）字节流

- 【**步骤：加载**】

  加载，是指**查找字节流，并且据此创建类**的过程。前面提到，对**于数组类**来说，它并没有对应的字节流，而是**由 Java 虚拟机直接生成**的。对于其他的类来说，Java 虚拟机则需要**借助类加载器**来完成查找字节流的过程。

- 类加载器

  - 类加载器的祖师爷，启动类加载器（**bootstrap class loader**）。启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代
  - 除了启动类加载器之外，其他的类加载器都是 `java.lang.ClassLoader` 的子类，因此有对应的 Java 对象。`这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中`，方能执行类加载。
  - 在 Java 虚拟机中，这个潜规则有个特别的名字，叫**双亲委派模型**。每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。
  - 在 Java 9 之前，**启动类加载器**负责加载最为基础、最为重要的类，比如存放在 **JRE 的 lib 目录下 jar 包**中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）
  - **扩展类加载器**是启动类加载器子类。它负责加载相对次要、但又通用的类，比如存放在 **JRE 的 lib/ext** 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）
  - **应用类加载器**的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。
  - **Java 9** 引入了模块系统，并且略微更改了上述的类加载器。`扩展类加载器被改名为平台类加载器`（platform class loader）
  - 可以加入自定义的类加载器：可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。
  - 除了加载功能之外，类加载器还提供了命名空间的作用。
  - 在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的



- 【**步骤：链接**】

  **链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程**。它可分为**验证**、**准备**以及**解析**三个阶段。

  - **验证阶段**目的：确保被加载类能够满足 **Java 虚拟机的约束条件**
  - **准备阶段**的目的：是为**被加载类的静态字段分配内存**。（除了分配内存外，部分 Java 虚拟机还会在此阶段构造其他跟类层次相关的`数据结构`，比如说用来实现虚方法的动态绑定的方法表。）
  - 在 `class 文件被加载至 Java 虚拟机之前`，**这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址**。因此，每当需要引用这些成员时，Java 编译器会生成一个**符号引用**。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。
  - **解析阶段**的目的，正是**将这些符号引用解析成为实际引用**。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析`将触发这个类的加载`（但未必触发这个类的链接以及初始化。）
  - Java 虚拟机规范**并没有要求在链接过程中完成解析**。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，**需要完成对这些符号引用的解析**。



- 【**步骤：初始化**】

  类加载的最后一步是初始化，便是**为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程**。

  Java 虚拟机会**通过加锁来确保类的 < clinit > 方法仅被执行一次**。

  只有当初始化完成之后，类才正式成为`可执行的状态`。

  **类初始化是线程安全的，并且仅被执行一次**

  - 初始化一个静态字段：

    - 在声明时直接赋值
    - 也可以在静态代码块中对其赋值。

  - 如果**直接赋值的静态字段被 final 所修饰**，并且它的类型是**基本类型或字符串**时，那么该字段便会被 Java 编译器标记成**常量值**（ConstantValue），其初**始化直接由 Java 虚拟机**完成

  - 除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。

  - 类的初始化何时会被触发呢？

    ```
    1.当虚拟机启动时，初始化用户指定的主类
    2.当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类
    3.当遇到调用静态方法的指令时，初始化该静态方法所在的类
    4.当遇到访问静态字段的指令时，初始化该静态字段所在的类
    5.子类的初始化会触发父类的初始化
    6.如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化
    7.使用反射 API 对某个类进行反射调用时，初始化这个类
    8.当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。
    ```

  - 单例延迟初始化例子

    ```java
    
    public class Singleton {
      private Singleton() {}
      private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
      }
      public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
      }
    }
    ```

    只有当调用 `Singleton.getInstance` 时，程序才会访问 `LazyHolder.INSTANCE`，才会触发对 `LazyHolder` 的初始化（对应第 4 种情况），继而新建一个 Singleton 的实例。

- 总结与实践

- 今天我介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。

- ```
  加载是指查找字节流，并且据此创建类的过程。
  	加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
  链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。
  	链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。
  初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。
  	类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。
  ```

- 思考题很好（包括评论）！！多看几遍+补做实验！！！

```shell
echo '
public class Singleton {
  private Singleton() {}
  private static class LazyHolder {
    static final Singleton INSTANCE = new Singleton();
    static {
      System.out.println("LazyHolder.<clinit>");
    }
  }
  public static Object getInstance(boolean flag) {
    if (flag) return new LazyHolder[2];
    return LazyHolder.INSTANCE;
  }
  public static void main(String[] args) {
    getInstance(true);
    System.out.println("----");
    getInstance(false);
  }
}' > Singleton.java
javac Singleton.java
java -verbose:class Singleton
```

