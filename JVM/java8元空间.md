- <https://www.cnblogs.com/moonandstar08/p/5001914.html>



Java8取消了永久代，把元数据移到了一个与堆不相连的本地内存区域。



## 移除永久代的影响

​    由于类的**元数据分配在本地内存中**，**元空间的最大可分配空间就是系统可用内存空间**。因此，默认情况下，元空间的大小仅受本地内存限制。因此，我们就**不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情**。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。

**注意**：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。



## 元空间内存管理

​    **元空间的内存管理由元空间虚拟机来完成**。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。

​    我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。**当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。**在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。

​    **元空间虚拟机负责元空间的分配，其采用的形式为组块分配。**组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。

![img](https://images2015.cnblogs.com/blog/37237/201511/37237-20151127223929327-212664215.png)

参考如下链接：http://www.infoq.com/cn/articles/Java-PERMGEN-Removed?from=groupmessage&isappinstalled=0



但可以通过以下参数来**指定元空间的大小**：

`-XX:MetaspaceSize` 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过`MaxMetaspaceSize`时，适当提高该值。
`-XX:MaxMetaspaceSize`最大空间，默认是没有限制的。

除了上面两个**指定大小的选项**以外，还有**两个与 GC 相关的属性**：

`-XX:MinMetaspaceFreeRatio`在GC之后，最小的`Metaspace`剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
`-XX:MaxMetaspaceFreeRatio`在GC之后，最大的`Metaspace`剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
————————————————

原文链接：https://blog.csdn.net/u010588262/article/details/81365547



【如果没有则在常量池中创建一个此字符串对象】这句话在JDK7以后就是错的，字符串对象永远在堆上，常量池里面存的是字面量和引用