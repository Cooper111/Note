# 网络模型

`OSI`七层和`TCP/IP`五层模型，有哪些必会的知识点呢？

我先来问个问题，拥塞控制发生在OSI模型第几层？

> 答：网络层

以下是我认为得了解的

- #### 各层职责，[传送门见此](<https://blog.csdn.net/chengonghao/article/details/51892667/>)

- #### 各层协议:

- #### 跟着`osi`七层和`tcp/ip`五层模型走一遍数据传输流程

- #### 网络层—寻址`ip`

  网络号：IP（主机号）和掩码得到的。

  举个例子，使用`cat /etc/network/interfaces`命令获得以下信息：

  e.g. 

  ```
  IPADDR=192.168.150.12
  NETMASK=255.255.255.0
  GATEWAY=192.168.150.2
  DNS1=233.5.5.5
  DNS2=114.114.114.114
  ```

  那么网络号为`192.168.150.0`

  

- #### 网络层—路由route

  大致流程知道吧，访问的IP与子网掩码做与运算，得到的网络号与路由表中下一跳地址相比较，相同则跳。

  举个例子，会模拟以下情况：

  

  - 都在一个局域网内，`ip`为192.168.150.X的两台机器a和b，直接可以通过eth0连接到192.168.150.0这个网络；如果访问这个网络内主机，可直接通信不需要跳跃

  - 访问`www.baidu.com`，百度的ip是`61.135.169.125`。然后到了路由表，将百度的ip`61.135.169.125`与掩码依次做与运算，得到61.135.169.0，和`192.168.150.0`（路由表该记录中的目标地址）不匹配

    与第二个掩码做与运算，得到61.135.0.0，和169.254.0.0不一样，不匹配

    与第三个掩码做与运算，得到0.0.0.0，和0.0.0.0一样，匹配，路由器转发到对应网关`192.168.150.2`

    （`ps`：掩码和网络号都为`0.0.0.0`的叫做默认网关）

    

- #### ARP协议

  

  网络层封百度（请求端）的IP地址，而如何正确到下一跳地址？链路层封个下一跳的MAC地址（ARP协议）







# 文件描述符 

​	刚刚是纯网络部分，别急，慢慢就进入IO部分了，你会发现所有知识都是串起来的~



`Liuix`有个概念，“一切皆文件”。什么意思呢？

- “打开open –> 读写write/read –> 关闭close"这样进行操作
- 也就是都具有输入流、输出流、和错误流

来直观感受下：

（图）

- $$ 这个程式的PID(脚本运行的当前[进程ID](https://www.baidu.com/s?wd=%E8%BF%9B%E7%A8%8BID&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)号)，使用$$可以查看当前exec进程的PID。

- 然后进入`/proc/2640/fd`，看着像文件，其实`/proc/`存放的是进程，这里的意思是进入进入PID为2640的进程的文件描述符集，进行查看。这里看到文件描述符8，即是一个socket！

- 所以socket，也是一个“ 文件 ”。







# Socket概念及函数

网上讲的已经很成熟了，这里我推荐一个我认为讲的很好的，[放一个传送门](<https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html>)

**主要该了解哪些呢？**归纳如下（其实就是上文的目录hhh）：

- Socket是什么？
- socket的基本操作
  - socket()函数
  - bind()函数
  - listen()、connect()函数
  - accept()函数
  - read()、write()函数等
  - close()函数
- socket中TCP的三次握手建立连接详解
- socket中TCP的四次握手释放连接详解
- 一个例子（C语言）



这时候再看[这个例子](<https://blog.csdn.net/zhjutao/article/details/8622751>),见这里的链接

```shell
 exec 8<>/dev/tcp/www.csdn.net/80
 echo -e "GET">8&
 cat<&8
```

- exec 设置新的fd为socket，规定输入输出流到 `/dev/tcp/www.csdn.net/80`（`<>`代表输入输出流）

- 这里应该写`echo -e "GET /HTTP/1.0\n" 1>& 8`。 意思是echo输入命令，从当前exec进程的1（标准输出流）重定向到文件描述符8进行输出，于是socket访问csdn。

- 然后exec的0（输入流）重定向到8，于是输出8的返回值，就是csdn想响应

  

这里是不是一目了然啦，应该对socket印象也深了~



# Socket在TCP建立连接时有几个？

> 答：有3个。
>
> 下面是截取一篇文章中的段落，具体哪里搞忘记了   030

​	**首先**，我们创建 `ServerSocket` 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 `ServerSocket` 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 `listen` 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。

​	**接下来**，我们的客户端创建一个 `Socket`，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 `ServerSocket` 一开始创建的那个没有什么区别。不同的是，接下来 `Socket` 会对它执行 `connect`，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 `connect` 后，内核会发送一个 `SYN` 给服务端。

​	**现在**，我们切换角色到服务端。**服务端的主机在收到这个 SYN 后，会创建一个新的 socket**，这个新创建的 socket 跟客户端继续执行三次握手过程。

​	**三次握手完成后**，我们执行的 `serverSocket.accept()` 会返回一个 `Socket` 实例，这个 socket 就是上一步内核自动帮我们创建的。

​	**所以说**，在一个客户端连接的情况下，其实有 3 个 socket。

关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 `ServerSocket` 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。

### 如何区分Socket？

​	前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 `<peer addr:peer port, local addr:local port>` 这个四元组。

​	在上面的例子中，

- 我们的 `ServerSocket` 长这样：`<*:*, *:9877>`。意思是，可以接受任何的客户端，和本地任何 IP。

- `accept` 返回的 `Socket` 则是这样：
  `<127.0.0.1:xxxx, 127.0.0.1:9877>`，其中`xxxx` 是客户端的端口号。



**如果数据是发送给一个已连接的 socket**，内核会找到一个**完全匹配**的实例，所以数据准确发送给了对端。

**如果是客户端要发起连接**，这时候**只有 `<*:*, *:9877>` 会匹配成功**，所以 `SYN` 也准确发送给了监听套接字。

`Socket/ServerSocket` 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP/IP 详解》卷1、卷2。



然后这里放个图（马士兵教育试听课dei）

![](F:/JAVA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%81IO/images/socket3.png)

可以看到：

- 第五个`<*:*, *:22>`是LISTEN状态，等待客户端发起连接
- 第二、三、四是完全匹配的Socket



这里可以看到，每个socket对应一个进程。那么能否多个socket对应一个进程？

能，**IO多路复用（SELECT，POLL，EPOLL）**，学到Netty的时候会挖。





# 结束语

淦，累死了，早知道上课好好学了，就不用再倒腾复习梳理一遍了···